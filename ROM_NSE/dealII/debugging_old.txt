  template <int dim>
  void NavierStokes<dim>::assemble_nonlinearity_tensor_pressure(std::vector<Vector<double>> &pod_vectors)
  {
    // reinit the tensor
    int r_p = pod_vectors.size();
    nonlinear_tensor_pressure.resize(r_p);
    for (int i = 0; i < r_p; i++)
      nonlinear_tensor_pressure[i].reinit(sparsity_pattern_velocity);

    QGauss<dim> quadrature_formula(2 * fe_velocity.degree + 2);

    FEValues<dim> fe_values(fe_velocity,
                        quadrature_formula,
                        update_values | update_gradients | update_quadrature_points | update_JxW_values);
    FEValues<dim> fe_values_pressure(fe_pressure,
                        quadrature_formula,
                        update_values | update_gradients | update_quadrature_points | update_JxW_values);

    const unsigned int dofs_per_cell = fe_velocity.n_dofs_per_cell();

    const unsigned int n_q_points = quadrature_formula.size();

    FullMatrix<double> local_matrix(dofs_per_cell, dofs_per_cell);

    std::vector<unsigned int> local_dof_indices(dofs_per_cell);

    const FEValuesExtractors::Vector velocities(0);

    for (int i = 0; i < r_p; i++)
    {
      // contribution of the i.th POD vector
      std::vector<double> pod_vector_values(n_q_points);

      // test functions
      std::vector<Tensor<2, dim>> phi_j_grads(dofs_per_cell);

      typename DoFHandler<dim>::active_cell_iterator
        cell = dof_handler_velocity.begin_active(),
        endc = dof_handler_velocity.end();
      typename DoFHandler<dim>::active_cell_iterator
        cell_p = dof_handler_pressure.begin_active(),
        endc_p = dof_handler_pressure.end();

      // Next, we run over all cells
      for (; cell != endc; ++cell, ++cell_p)
      {
        fe_values.reinit(cell);
        fe_values_pressure.reinit(cell_p);
        local_matrix = 0;

        fe_values_pressure.get_function_values(pod_vectors[i], pod_vector_values);

        for (unsigned int q = 0; q < n_q_points; ++q)
        {
          for (unsigned int l = 0; l < dofs_per_cell; ++l)
          {
            phi_j_grads[l] = fe_values[velocities].gradient(l, q);
          }

          double psi = pod_vector_values[q];

          // Outer loop for dofs
          for (unsigned int j = 0; j < dofs_per_cell; ++j)
          {
            // Inner loop for dofs
            for (unsigned int k = 0; k < dofs_per_cell; ++k)
            {
              /*
              double tmp = phi_j_grads[k][0][0] * phi_j_grads[j][0][0];
              tmp += phi_j_grads[k][1][1] * phi_j_grads[j][1][1];
              tmp += 2 * phi_j_grads[k][1][0] * phi_j_grads[j][0][1];
              */

              double tmp = 0.0;
              for (unsigned int l = 0; l < dim; l++)
                for (unsigned int m = 0; m < dim; m++)
                  tmp += phi_j_grads[k][l][m] * phi_j_grads[j][m][l];

              local_matrix(j, k) += tmp * psi * fe_values.JxW(q);
            } // end k dofs
          } // end j dofs
        } // end n_q_points

        // This is the same as discussed in step-22:
        cell->get_dof_indices(local_dof_indices);
        no_constraints.distribute_local_to_global(local_matrix, local_dof_indices,
                                               nonlinear_tensor_pressure[i]);
        // end cell
      }
    } // end iteration over POD vectors

  }

  template <int dim>
  Vector<double> NavierStokes<dim>::reconstruct_pressure_FEM(Vector<double> &velocity_solution)
  {
    // create a vector for thre reconstructed pressure
    Vector<double> pressure_solution(dof_handler_pressure.n_dofs());

    // assemble the right hand side vector of the Poisson equation
    Vector<double> right_hand_side(dof_handler_pressure.n_dofs());

    // ASSEMBLY:
    QGauss<dim> quadrature_formula(2 * fe_pressure.degree + 2);

    FEValues<dim> fe_values(fe_velocity,
                        quadrature_formula,
                        update_values | update_gradients | update_quadrature_points | update_JxW_values);
    FEValues<dim> fe_values_pressure(fe_pressure,
                        quadrature_formula,
                        update_values | update_gradients | update_quadrature_points | update_JxW_values);

    const unsigned int dofs_per_cell = fe_pressure.dofs_per_cell;
    Vector<double> local_rhs(dofs_per_cell);
    std::vector<unsigned int> local_dof_indices(dofs_per_cell);

    const unsigned int n_q_points = quadrature_formula.size();
    const FEValuesExtractors::Vector velocities(0);

    std::vector<std::vector<Tensor<1, dim>>>
        velocity_grads(n_q_points, std::vector<Tensor<1, dim>>(dim));

    typename DoFHandler<dim>::active_cell_iterator
      cell = dof_handler_velocity.begin_active(),
      endc = dof_handler_velocity.end();
    typename DoFHandler<dim>::active_cell_iterator
      cell_p = dof_handler_pressure.begin_active(),
      endc_p = dof_handler_pressure.end();

    // Next, we run over all cells
    for (; cell != endc; ++cell, ++cell_p)
    {
      fe_values.reinit(cell);
      fe_values_pressure.reinit(cell_p);

      fe_values.get_function_gradients(velocity_solution, velocity_grads);

      for (unsigned int q = 0; q < n_q_points; ++q)
      {
        Tensor<2, dim> grad_v;
        for (unsigned int l = 0; l < dim; l++)
          for (unsigned int m = 0; m < dim; m++)
            grad_v[l][m] = velocity_grads[q][l][m];

        double tmp = 0.0;
        for (unsigned int l = 0; l < dim; l++)
          for (unsigned int m = 0; m < dim; m++)
            tmp += grad_v[l][m] * grad_v[m][l];

        for (unsigned int i = 0; i < dofs_per_cell; ++i)
        {
          local_rhs(i) += fluid_density * tmp * fe_values_pressure.shape_value(i, q) * fe_values_pressure.JxW(q);
        }
      } // end n_q_points

      cell_p->get_dof_indices(local_dof_indices);
      pressure_constraints.distribute_local_to_global(local_rhs, local_dof_indices,
                                             right_hand_side);
      // end cell
    }

    /*
    for (unsigned int i = 0; i < dof_handler_pressure.n_dofs(); ++i)
    {
      std::vector<std::vector<Tensor<1, dim>>>
          velocity_grads(n_q_points, std::vector<Tensor<1, dim>>(dim));
      std::vector<double> basis_vector_values(n_q_points);

      Vector<double> pressure_basis(dof_handler_pressure.n_dofs());
      pressure_basis[i] = 1.0;

      typename DoFHandler<dim>::active_cell_iterator
        cell = dof_handler_velocity.begin_active(),
        endc = dof_handler_velocity.end();
      typename DoFHandler<dim>::active_cell_iterator
        cell_p = dof_handler_pressure.begin_active(),
        endc_p = dof_handler_pressure.end();

      // Next, we run over all cells
      for (; cell != endc; ++cell, ++cell_p)
      {
        fe_values.reinit(cell);
        fe_values_pressure.reinit(cell_p);

        fe_values.get_function_gradients(velocity_solution, velocity_grads);

        fe_values_pressure.get_function_values(pressure_basis, basis_vector_values);

        for (unsigned int q = 0; q < n_q_points; ++q)
        {
          double psi = basis_vector_values[q];

          Tensor<2, dim> grad_v;
          for (unsigned int l = 0; l < dim; l++)
            for (unsigned int m = 0; m < dim; m++)
              grad_v[l][m] = velocity_grads[q][l][m];

          double tmp = 0.0;
          for (unsigned int l = 0; l < dim; l++)
            for (unsigned int m = 0; m < dim; m++)
              tmp += grad_v[l][m] * grad_v[m][l];

          right_hand_side[i] += fluid_density * tmp * psi * fe_values_pressure.JxW(q);

        } // end n_q_points
        // end cell
      }
    }
    */
    /*
    std::cout << "right hand side: " << std::endl;
    right_hand_side.print(std::cout);
    exit(8);
    */

    std::map<types::global_dof_index, double> boundary_values;
    VectorTools::interpolate_boundary_values(dof_handler_pressure,
                                             1,
                                             Functions::ZeroFunction<dim>(),
                                             boundary_values);
    MatrixTools::apply_boundary_values(boundary_values,
                                       laplace_matrix_pressure_with_bc,
                                       pressure_solution,
                                       right_hand_side);

    std::cout << "righ_hand_side: " << std::endl;
    right_hand_side.print(std::cout);

    /*
    // direct solver:
    laplace_matrix_pressure_inverse.vmult(pressure_solution, right_hand_side); // iterative solver instead ?
    std::cout << "pressure solution (direct solver): [norm: " << pressure_solution.l2_norm() << " ]" << std::endl;
    pressure_solution.print(std::cout);
    pressure_solution = 0.0;
    */

    std::ofstream matrix_stream("pressure_laplace_matrix.txt");
    matrix_stream << std::setprecision(16);
    laplace_matrix_pressure_with_bc.print(matrix_stream);

    // iterative solver:
    SolverControl            solver_control(30000, 1e-10 * right_hand_side.l2_norm());
    SolverCG<Vector<double>> gmres(solver_control);
    gmres.solve(laplace_matrix_pressure_with_bc, pressure_solution, right_hand_side, PreconditionIdentity());


    return pressure_solution;
  }
