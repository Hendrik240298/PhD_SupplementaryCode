'''
Take the results generated by compute_FOM_parameter_space.py and use these to build and compute ROM.
'''

import time

import dolfin
import multiprocessing as mp

# from mshr import *
import matplotlib.pyplot as plt
import numpy as np
import rich.console
import rich.table
from dolfin import *

from FOM import FOM
from ROM import ROM

from greedy_enrichement import greedy_enrichment

import pickle

import logging
# configure logger
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s", datefmt="%H:%M:%S"
)



import argparse

# Create the parser
parser = argparse.ArgumentParser(description="Compute FOM for a range of Reynolds numbers.")

# Add the arguments
parser.add_argument('--start', type=int, default=50, help='The start value for the Reynolds numbers.')
parser.add_argument('--end', type=int, default=200, help='The stop value for the Reynolds numbers.')
parser.add_argument('--step', type=int, default=5, help='The step value for the Reynolds numbers.')


parser.add_argument('--venergy', type=float, default=1e-6, help='Pressure POD energy loss.')
parser.add_argument('--penergy', type=float, default=1e-6, help='Pressure POD energy loss.')

parser.add_argument('--reynolds', type=int, default=100, help='Pressure POD energy loss.')

parser.add_argument('--one_size_POD', type=bool, default=False, help='All POD size of pressure.')



# Parse the arguments
args = parser.parse_args()

print(args.start, args.end, args.step)

# Turn off interactive mode
plt.ioff()

# from os import environ
# environ['OMP_NUM_THREADS'] = '32'

# ---------- FEniCS parameters ---------
parameters["reorder_dofs_serial"] = False
set_log_active(False) # turn off FEniCS logging

# ----------- FOM parameters -----------
# nu = Constant(0.001)    
theta = 0.5
T =  20.0 # 5.  # 10.0
dt = 0.01
n_timesteps = int(T / dt)
# dt = T / n_timesteps

# ----------- ROM parameters -----------
REL_ERROR_TOL = 1e-2
MAX_ITERATIONS = 100
TOTAL_ENERGY = {
    "primal": {
        "velocity": 1 - args.venergy,
        "pressure": 1 - args.penergy,
    },
}


Re = np.arange(args.start, args.end+1, args.step)

# find nearest reynolds number and its index to args.reynolds
parameter_index = np.argmin(np.abs(Re - args.reynolds))

# parameter_index = 0

logging.info(f"Re = {Re}")

logging.info(f"====================================")
logging.info(f"Analysed Reynolds numbers: {Re[parameter_index]}")
logging.info(f"with v/p POD energy loss:  {args.venergy} / {args.penergy}")
logging.info(f"====================================")


# one FOM for whole parameter space 
master_FOM = FOM(0, T, dt, theta, 0.1/Re[parameter_index])

STARTING_TIME = 5.0
STARTING_POINT = np.where(master_FOM.time_points >= STARTING_TIME)[0][0]

# if master_FOM.load_solution_parallel() == False:
#     master_FOM.solve_primal(force_recompute=False)

# solve auxiliary FOM cost functionals 
master_FOM.load_solution_parallel()
master_FOM.compute_drag_lift()

# logging.info(f"# time points = {len(fom.time_points)}")
# logging.info(f"# Re = {len(Re)}")

# fom.time_points = np.arange(fom.t, len(Re) * fom.T + fom.dt, fom.dt)

# logging.info(f"# time points = {len(fom.time_points)}")


master_ROM = ROM(
    master_FOM,
    REL_ERROR_TOL=REL_ERROR_TOL,
    MAX_ITERATIONS=MAX_ITERATIONS,
    TOTAL_ENERGY=TOTAL_ENERGY,
    STARTING_TIME=STARTING_TIME,
)

# compute lifting that can be used for all Re, but initialize with first Re
master_ROM.compute_lifting_function(force_recompute=True)

master_FOM.assemble_lifting_matrices(lifting=master_ROM.lifting)

# FOM Matrices
master_FOM.assemble_linear_operators()



# ====================================
# Build large POD 
# ====================================

# try to load pod, else build it
# shift to exlude "Einschwingphase"

shift = 500


FIXED_POD_SIZE = 200

# greedy_enrichment(Re, master_ROM)

try:
    # data = dict(np.load(f"results/POD_{args.start}_{args.end}.npz", allow_pickle=True))
    logging.info("Loading POD basis from disk")

    with open(f"results/POD_{args.start}_{args.end}_{STARTING_TIME}_200_modes.pickle", 'rb') as f:
        data = pickle.load(f)
    
    master_ROM.POD = data
    
except:  
    FOM_snapshots = {
        "velocity": np.empty((master_FOM.dofs["velocity"], 0)),
        "pressure": np.empty((master_FOM.dofs["pressure"], 0)),
        "supremizer": np.empty((master_FOM.dofs["velocity"], 0)),
    }

    # make a dictionary of fom classes with reynolds number as key
    FOM_dict = {}
    ROM_dict = {}
    for re in Re:
        fom = FOM(0, T, dt, theta, 0.1/re)
        # fom.load_solution_parallel()
        FOM_dict[re] = fom
        ROM_dict[re] = ROM(
            fom,
            REL_ERROR_TOL=REL_ERROR_TOL,
            MAX_ITERATIONS=MAX_ITERATIONS,
            TOTAL_ENERGY=TOTAL_ENERGY,
        )    

    for re in Re:
        logging.info(f"Re = {re}")
        # fom = FOM(0, T, dt, theta, 0.1/re)
        FOM_dict[re].load_solution_parallel()
        FOM_snapshots["velocity"] = np.hstack((FOM_snapshots["velocity"], FOM_dict[re].Y["velocity"][:, STARTING_POINT:]))
        FOM_snapshots["pressure"] = np.hstack((FOM_snapshots["pressure"], FOM_dict[re].Y["pressure"][:, STARTING_POINT:]))
        
    for re in Re:    
        ROM_dict[re].compute_supremizer(force_recompute=False)
        FOM_snapshots["supremizer"] = np.hstack((FOM_snapshots["supremizer"], ROM_dict[re].fom.Y["supremizer"][:, STARTING_POINT:]))

    # lists of matrix array to a single numpy arrays by concatenating along axis 1


    # FOM_snapshots["velocity"] = np.concatenate(FOM_snapshots["velocity"], axis=1)
    # FOM_snapshots["pressure"] = np.concatenate(FOM_snapshots["pressure"], axis=1)
    # FOM_snapshots["supremizer"] = np.concatenate(FOM_snapshots["supremizer"], axis=1)

    # subtract lifting function for velocity and supremizer from each column vector

    for i in range(FOM_snapshots["velocity"].shape[1]):
        FOM_snapshots["velocity"][:,i] -= master_ROM.lifting["velocity"]
        FOM_snapshots["supremizer"][:,i] -= master_ROM.lifting["velocity"]

    logging.info(f"shape of FOM_snapshots['velocity'] = {FOM_snapshots['velocity'].shape}")
    logging.info(f"shape of FOM_snapshots['pressure'] = {FOM_snapshots['pressure'].shape}")
    logging.info(f"shape of FOM_snapshots['supremizer'] = {FOM_snapshots['supremizer'].shape}")
    
    logging.info("Starting POD (SVD) computation")
    # build and init POD bases 

    master_ROM.POD["primal"]["velocity"]["bunch_size"] = int(FOM_snapshots["velocity"].shape[1]/len(Re))
    master_ROM.POD["primal"]["pressure"]["bunch_size"] = int(FOM_snapshots["pressure"].shape[1]/len(Re))
    master_ROM.POD["primal"]["supremizer"]["bunch_size"] = int(FOM_snapshots["supremizer"].shape[1]/len(Re))

    logging.info(f"bunch size = {master_ROM.POD['primal']['velocity']['bunch_size']} and #snapshots = {FOM_snapshots['velocity'].shape[1]}")    # loop over columns of FOM_snapshots 
    for i in range(FOM_snapshots["velocity"].shape[1]):
        master_ROM.iPOD(FOM_snapshots["velocity"][:, i], type="primal", quantity="velocity", equal_size=False, FIXED_POD_SIZE = FIXED_POD_SIZE)
        master_ROM.iPOD(FOM_snapshots["pressure"][:, i], type="primal", quantity="pressure", equal_size=False, FIXED_POD_SIZE = FIXED_POD_SIZE)
        master_ROM.iPOD(FOM_snapshots["supremizer"][:, i], type="primal", quantity="supremizer") 

    # logging.info(f"VELOCITY POD size:   {master_ROM.POD['primal']['velocity']['basis'].shape[1]}")
    # logging.info(f"PRESSURE POD size:   {master_ROM.POD['primal']['pressure']['basis'].shape[1]}")
    # logging.info(f"SUPREMIZER POD size: {master_ROM.POD['primal']['supremizer']['basis'].shape[1]}")

    # master_ROM.iPOD(FOM_snapshots["velocity"][:, -1], type="primal", quantity="velocity", equal_size=False, empty_bunch_matrix=True)
    # master_ROM.iPOD(FOM_snapshots["pressure"][:, -1], type="primal", quantity="pressure", equal_size=False, empty_bunch_matrix=True)
    # master_ROM.iPOD(FOM_snapshots["supremizer"][:, -1], type="primal", quantity="supremizer", empty_bunch_matrix=True)

    # master_ROM.iPOD(FOM_snapshots["velocity"], type="primal", quantity="velocity", equal_size=True)
    # master_ROM.iPOD(FOM_snapshots["pressure"], type="primal", quantity="pressure", equal_size=True)
    # master_ROM.iPOD(FOM_snapshots["supremizer"], type="primal", quantity="supremizer")

    logging.info(f"VELOCITY POD size:   {master_ROM.POD['primal']['velocity']['basis'].shape[1]}")
    logging.info(f"PRESSURE POD size:   {master_ROM.POD['primal']['pressure']['basis'].shape[1]}")
    logging.info(f"SUPREMIZER POD size: {master_ROM.POD['primal']['supremizer']['basis'].shape[1]}")

    # save the POD dict to disk in results dir
    np.savez(f"results/POD_{args.start}_{args.end}_{STARTING_TIME}_200_modes.npz", **master_ROM.POD)
    with open(f"results/POD_{args.start}_{args.end}_{STARTING_TIME}_200_modes.pickle", 'wb') as f:
        pickle.dump(master_ROM.POD, f)


# ================================
# Define POD basis size 
# ================================

all_are_equal = args.one_size_POD

for quantity in ["pressure", "velocity", "supremizer"]:
    S_k = master_ROM.POD["primal"][quantity]["sigs"]
    r = 0
    if quantity != "supremizer":
        while (
                np.dot(S_k[0:r], S_k[0:r])
                <= master_ROM.POD["primal"][quantity]["energy"] * TOTAL_ENERGY["primal"][quantity]
            ) and (
                r < np.shape(S_k)[0]
            ):
            r += 1     
    else:
        r = master_ROM.POD["primal"]["pressure"]["basis"].shape[1]

    if all_are_equal == True:
        if quantity == "velocity":
            r = master_ROM.POD["primal"]["pressure"]["basis"].shape[1]

    master_ROM.POD["primal"][quantity]["sigs"] = S_k[0:r]
    master_ROM.POD["primal"][quantity]["basis"] = master_ROM.POD["primal"][quantity]["basis"][:, 0:r]


# monitor sizes of PODs
logging.info(f"VELOCITY POD size:   {master_ROM.POD['primal']['velocity']['basis'].shape[1]}")
logging.info(f"PRESSURE POD size:   {master_ROM.POD['primal']['pressure']['basis'].shape[1]}")
logging.info(f"SUPREMIZER POD size: {master_ROM.POD['primal']['supremizer']['basis'].shape[1]}")

# continue with normal ROM computation stuff 
master_ROM.compute_reduced_matrices()


# solve ROM
logging.info("Starting ROM solve")
tic = time.time()
master_ROM.solve_primal()
toc = time.time()
logging.info(f"ROM solve time: {toc - tic}")
master_ROM.compute_drag_lift()


# find where time points is >= 15
index = np.where(master_ROM.fom.time_points > 18.)[0][0]
index_end = np.where(master_ROM.fom.time_points > 20)[0][0]


# since we start at t = 5 this is shifted by 5s
index_rom_start = np.where(master_ROM.fom.time_points >= 13.)[0][0]
index_rom_end = np.where(master_ROM.fom.time_points >= 15)[0][0]

#index_rom_start = 2
#index_rom_end = index_end - index +2

## Plotting Parameters 
FONT_SIZE_AXIS = 15
FONT_LABEL_SIZE = 13

print(f"# time points: {len(master_ROM.fom.time_points[index:index_end])}")
print(f"# rom points: {len(master_ROM.drag_force[index_rom_start:index_rom_end])}")

rom_shift = 1

if args.start == 100 and args.end == 100 and args.reynolds == 100: 
    rom_shift = 1 # correct!
elif args.start == 100 and args.end == 200 and args.reynolds == 100: 
    rom_shift = 0
elif args.start == 100 and args.end == 200 and args.reynolds == 200:
    rom_shift = 1 # correct!


# ===============================================================
# Single plots for thesis 
# ===============================================================
# Enable LaTeX interpreter
plt.rcParams['text.usetex'] = True

## Drag force plot 
plt.close('all')

### FOM 
plt.plot(
    master_FOM.time_points[index-2:index_end], 
    master_FOM.drag_force[index-2:index_end], 
    linewidth=3,
    color="#1f77b4",
    label="FOM"
    )

### ROM 
plt.plot(
    master_ROM.fom.time_points[index-2:index_end],
    master_ROM.drag_force[index_rom_start+rom_shift-2:index_rom_end+rom_shift], 
    linewidth=3,
    color="red",
    linestyle=":",
    label="ROM"
    )

### specs
plt.xlabel(r"time $[s]$", fontsize = FONT_SIZE_AXIS)
plt.ylabel(r"$C_D$", fontsize = FONT_SIZE_AXIS)
plt.legend(fontsize = FONT_LABEL_SIZE, loc="upper right")
plt.tick_params(axis="both", which="major", labelsize=13)

plt.xticks([18, 18.5, 19, 19.5, 20])
# plt.xlim(18, 20)
plt.grid()
# Adjust layout to prevent y-label from being cut off
plt.tight_layout()

plot_name = f"plots/drag_parameterized_Re_{Re[parameter_index]}_start_{args.start}_end_{args.end}_step_{args.step}_POD_{master_ROM.POD['primal']['velocity']['basis'].shape[1]}+{master_ROM.POD['primal']['pressure']['basis'].shape[1]}_venergy_{args.venergy}_penergy_{args.penergy}.pdf"
plt.savefig(plot_name)
plt.close('all')


## Lift force plot
### FOM 
plt.plot(
    master_FOM.time_points[index-2:index_end], 
    master_FOM.lift_force[index-2:index_end], 
    linewidth=3,
    color="#1f77b4",
    label="FOM"
    )

### ROM 
plt.plot(
    master_ROM.fom.time_points[index-2:index_end],
    master_ROM.lift_force[index_rom_start+rom_shift-2:index_rom_end+rom_shift], 
    linewidth=3,
    color="red",
    linestyle=":",
    label="ROM"
    )

### specs
plt.xlabel(r"time $[s]$", fontsize = FONT_SIZE_AXIS)
plt.ylabel(r"$C_L$", fontsize = FONT_SIZE_AXIS)
plt.legend(fontsize = FONT_LABEL_SIZE, loc="upper right")
plt.tick_params(axis="both", which="major", labelsize=13)


plt.xticks([18, 18.5, 19, 19.5, 20])
# plt.xlim(18, 20)
plt.grid()
# Adjust layout to prevent y-label from being cut off
plt.tight_layout()

plot_name = f"plots/lift_parameterized_Re_{Re[parameter_index]}_start_{args.start}_end_{args.end}_step_{args.step}_POD_{master_ROM.POD['primal']['velocity']['basis'].shape[1]}+{master_ROM.POD['primal']['pressure']['basis'].shape[1]}_venergy_{args.venergy}_penergy_{args.penergy}.pdf"
plt.savefig(plot_name)
plt.close('all')






# ===============================================================
# Flow field plots for thesis 
# ===============================================================

FOM_sol_index = index
ROM_sol_index = index_rom_start+rom_shift


sol_time = 10.0
FOM_sol = {
    "velocity": master_FOM.Y["velocity"][:, FOM_sol_index],
    "pressure": master_FOM.Y["pressure"][:, FOM_sol_index],
}

ROM_sol = {
    "velocity": master_ROM.solution["primal"]["velocity"][:, ROM_sol_index],
    "pressure": master_ROM.solution["primal"]["pressure"][:, ROM_sol_index],
}


## ROM solution

sol_velocity = master_ROM.project_vector(
    ROM_sol["velocity"], type="primal", quantity="velocity"
) + master_ROM.lifting["velocity"]

sol_pressure = master_ROM.project_vector(
    ROM_sol["pressure"], type="primal", quantity="pressure"
)

v, p = master_ROM.fom.U_n.split()

master_ROM.fom.U_n.vector().set_local(
    np.concatenate(
        (
            sol_velocity,
            sol_pressure,
        )
    )
)

## FOM solution

sol_velocity_fom = FOM_sol["velocity"]
sol_pressure_fom = FOM_sol["pressure"]

v_error, p_error = master_FOM.U_n.split()

master_FOM.U_n.vector().set_local(
    np.concatenate(
        (
            sol_velocity_fom - sol_velocity,
            sol_pressure_fom - sol_pressure,
        )
    )
)


# velcoity
# subplot for velocuty: rom field and |fom-rom| error field

v, p = master_ROM.fom.U_n.split()

master_ROM.fom.U_n.vector().set_local(
    np.concatenate(
        (
            sol_velocity,
            sol_pressure,
        )
    )
)

plt.figure(figsize=(8, 2.5))
c = plot(sqrt(dot(v, v)))
cb = plt.colorbar(c, orientation="horizontal")
cb.ax.tick_params(labelsize=13)  # Set colorbar font size

### specs
plt.tick_params(axis="both", which="major", labelsize=13)

plt.xticks([0.0, 0.5, 1.0 , 1.5, 2.0]) 
plt.yticks([0.0, 0.1, 0.2, 0.3, 0.4]) 
# Adjust layout to prevent y-label from being cut off
plt.tight_layout()

plot_name = f"plots/velocity_field_Re_{Re[parameter_index]}_start_{args.start}_end_{args.end}_step_{args.step}_POD_{master_ROM.POD['primal']['velocity']['basis'].shape[1]}+{master_ROM.POD['primal']['pressure']['basis'].shape[1]}_venergy_{args.venergy}_penergy_{args.penergy}.pdf"
plt.savefig(plot_name)
plt.close('all')

# plt.show()


plt.figure(figsize=(8, 2.5))

v_error, p_error = master_FOM.U_n.split()

master_FOM.U_n.vector().set_local(
    np.concatenate(
        (
            sol_velocity_fom - sol_velocity,
            sol_pressure_fom - sol_pressure,
        )
    )
)


c = plot(sqrt(dot(v_error, v_error)))

cb = plt.colorbar(c, orientation="horizontal")
cb.ax.tick_params(labelsize=13) 

### specs
plt.tick_params(axis="both", which="major", labelsize=13)

plt.xticks([0.0, 0.5, 1.0 , 1.5, 2.0]) 
plt.yticks([0.0, 0.1, 0.2, 0.3, 0.4]) 
# Adjust layout to prevent y-label from being cut off
plt.tight_layout()

plot_name = f"plots/velocity_field_error_Re_{Re[parameter_index]}_start_{args.start}_end_{args.end}_step_{args.step}_POD_{master_ROM.POD['primal']['velocity']['basis'].shape[1]}+{master_ROM.POD['primal']['pressure']['basis'].shape[1]}_venergy_{args.venergy}_penergy_{args.penergy}.pdf"
plt.savefig(plot_name)
plt.close('all')

# plt.show()









# pressure
# subplot for velocuty and pressure
plt.figure(figsize=(8, 2.5))
v, p = master_ROM.fom.U_n.split()

master_ROM.fom.U_n.vector().set_local(
    np.concatenate(
        (
            sol_velocity,
            sol_pressure,
        )
    )
)


c = plot(p)
cb = plt.colorbar(c, orientation="horizontal")
cb.ax.tick_params(labelsize=13) 

### specs
plt.tick_params(axis="both", which="major", labelsize=13)

plt.xticks([0.0, 0.5, 1.0 , 1.5, 2.0]) 
plt.yticks([0.0, 0.1, 0.2, 0.3, 0.4]) 
# Adjust layout to prevent y-label from being cut off
plt.tight_layout()

plot_name = f"plots/pressure_field_Re_{Re[parameter_index]}_start_{args.start}_end_{args.end}_step_{args.step}_POD_{master_ROM.POD['primal']['velocity']['basis'].shape[1]}+{master_ROM.POD['primal']['pressure']['basis'].shape[1]}_venergy_{args.venergy}_penergy_{args.penergy}.pdf"
plt.savefig(plot_name)
plt.close('all')

# plt.show()

plt.figure(figsize=(8, 2.5))
v_error, p_error = master_FOM.U_n.split()

master_FOM.U_n.vector().set_local(
    np.concatenate(
        (
            sol_velocity_fom - sol_velocity,
            np.abs(sol_pressure_fom - sol_pressure),
        )
    )
)


c = plot(p_error)
cb = plt.colorbar(c, orientation="horizontal")
cb.ax.tick_params(labelsize=13) 

### specs
plt.tick_params(axis="both", which="major", labelsize=13)

plt.xticks([0.0, 0.5, 1.0 , 1.5, 2.0]) 
plt.yticks([0.0, 0.1, 0.2, 0.3, 0.4]) 
# Adjust layout to prevent y-label from being cut off
plt.tight_layout()

plot_name = f"plots/pressure_field_error_Re_{Re[parameter_index]}_start_{args.start}_end_{args.end}_step_{args.step}_POD_{master_ROM.POD['primal']['velocity']['basis'].shape[1]}+{master_ROM.POD['primal']['pressure']['basis'].shape[1]}_venergy_{args.venergy}_penergy_{args.penergy}.pdf"
plt.savefig(plot_name)
plt.close('all')

# plt.show()
































# ===============================================================
# Large plots for debugging 
# ===============================================================
# compare ROM and FOM drag and lift coefficients in plot 
plt.figure(figsize=(10, 6))
plt.subplot(1, 2, 1)
plt.plot(
    master_FOM.time_points[index:index_end], 
    master_FOM.drag_force[index:index_end], 
    linewidth=3,
    color="#1f77b4",
    label="FOM"
    )
plt.plot(
    master_ROM.fom.time_points[index:index_end],
    master_ROM.drag_force[index_rom_start+rom_shift:index_rom_end+rom_shift], 
    linewidth=3,
    color="#ff7f0e",
    linestyle=":",
    label="ROM"
    )
plt.legend()
plt.grid()

plt.title("Drag Force")
plt.subplot(1, 2, 2)
plt.plot(
    master_FOM.time_points[index:index_end], 
    master_FOM.lift_force[index:index_end], 
    linewidth=3,
    color="#1f77b4",
    label="FOM"
    )
plt.plot(
    master_ROM.fom.time_points[index:index_end],
    master_ROM.lift_force[index_rom_start+rom_shift:index_rom_end+rom_shift],
    linewidth=3,
    color="#ff7f0e",
    linestyle=":",
    label="ROM"
    )
plt.legend()
plt.grid()
plt.title("Lift Force")

# plt.show()

# plt.savefig(f"plots/drag_lift_parameterized_Re_{Re[parameter_index]}_start_{args.start}_end_{args.end}_step_{args.step}_POD_{master_ROM.POD['primal']['velocity']['basis'].shape[1]}+{master_ROM.POD['primal']['pressure']['basis'].shape[1]}_venergy_{args.venergy}_penergy_{args.penergy}.pdf")




