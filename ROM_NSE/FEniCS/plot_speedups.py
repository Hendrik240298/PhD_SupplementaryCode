'''
Take the results generated by compute_FOM_parameter_space.py and use these to build and compute ROM.
'''

import time

import copy


import dolfin
import multiprocessing as mp

# from mshr import *
import matplotlib.pyplot as plt
import numpy as np
import rich.console
import rich.table
from dolfin import *

from FOM import FOM
from ROM import ROM

import pickle

import logging
# configure logger
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s", datefmt="%H:%M:%S"
)



import argparse

# Create the parser
parser = argparse.ArgumentParser(description="Compute FOM for a range of Reynolds numbers.")

# Add the arguments
parser.add_argument('--start', type=int, default=50, help='The start value for the Reynolds numbers.')
parser.add_argument('--end', type=int, default=200, help='The stop value for the Reynolds numbers.')
parser.add_argument('--step', type=int, default=5, help='The step value for the Reynolds numbers.')


# Parse the arguments
args = parser.parse_args()

print(args.start, args.end, args.step)

# Turn off interactive mode
plt.ioff()

# from os import environ
# environ['OMP_NUM_THREADS'] = '32'

# ---------- FEniCS parameters ---------
parameters["reorder_dofs_serial"] = False
set_log_active(False) # turn off FEniCS logging

# ----------- FOM parameters -----------
# nu = Constant(0.001)    
theta = 0.5
T =  20.0 # 5.  # 10.0
dt = 0.01
n_timesteps = int(T / dt)
# dt = T / n_timesteps

# ----------- ROM parameters -----------
REL_ERROR_TOL = 1e-2
MAX_ITERATIONS = 100
TOTAL_ENERGY = {
    "primal": {
        "velocity": 1 - 1e-8,
        "pressure": 1 - 1e-6,
    },
}


Re = np.arange(args.start, args.end+1, args.step)

logging.info(f"Re = {Re}")

parameter_index = 0

logging.info(f"Master Re: {Re[parameter_index]}")



# one FOM for whole parameter space 
master_FOM = FOM(0, T, dt, theta, 0.1/Re[parameter_index])


master_ROM = ROM(
    master_FOM,
    REL_ERROR_TOL=REL_ERROR_TOL,
    MAX_ITERATIONS=MAX_ITERATIONS,
    TOTAL_ENERGY=TOTAL_ENERGY,
)

# ====================================
# INIT FOR POD-ROM
# ====================================

SIZES = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150]

RECOMPUTE_RESULTS = False

if RECOMPUTE_RESULTS:
    
    # if master_FOM.load_solution_parallel() == False:
    #     master_FOM.solve_primal(force_recompute=False)

    # solve auxiliary FOM cost functionals 
    master_FOM.load_solution_parallel()
    master_FOM.compute_drag_lift()

    # logging.info(f"# time points = {len(fom.time_points)}")
    # logging.info(f"# Re = {len(Re)}")

    # fom.time_points = np.arange(fom.t, len(Re) * fom.T + fom.dt, fom.dt)

    # logging.info(f"# time points = {len(fom.time_points)}")


    master_ROM = ROM(
        master_FOM,
        REL_ERROR_TOL=REL_ERROR_TOL,
        MAX_ITERATIONS=MAX_ITERATIONS,
        TOTAL_ENERGY=TOTAL_ENERGY,
    )

    # compute lifting that can be used for all Re, but initialize with first Re
    master_ROM.compute_lifting_function(force_recompute=True)

    FOM_snapshots = {
        "velocity": np.empty((master_FOM.dofs["velocity"], 0)),
        "pressure": np.empty((master_FOM.dofs["pressure"], 0)),
        "supremizer": np.empty((master_FOM.dofs["velocity"], 0)),
    }

    # make a dictionary of fom classes with reynolds number as key
    FOM_dict = {}
    ROM_dict = {}
    for re in Re:
        fom = FOM(0, T, dt, theta, 0.1/re)
        # fom.load_solution_parallel()
        FOM_dict[re] = fom
        ROM_dict[re] = ROM(
            fom,
            REL_ERROR_TOL=REL_ERROR_TOL,
            MAX_ITERATIONS=MAX_ITERATIONS,
            TOTAL_ENERGY=TOTAL_ENERGY,
        )

    # shift to exlude "Einschwingphase"
    shift = 500

    for re in Re:
        logging.info(f"Re = {re}")
        # fom = FOM(0, T, dt, theta, 0.1/re)
        FOM_dict[re].load_solution_parallel()
        FOM_snapshots["velocity"] = np.hstack((FOM_snapshots["velocity"], FOM_dict[re].Y["velocity"][:, shift:]))
        FOM_snapshots["pressure"] = np.hstack((FOM_snapshots["pressure"], FOM_dict[re].Y["pressure"][:, shift:]))
        
    for re in Re:    
        ROM_dict[re].compute_supremizer(force_recompute=False)
        FOM_snapshots["supremizer"] = np.hstack((FOM_snapshots["supremizer"], ROM_dict[re].fom.Y["supremizer"][:, shift:]))

    # lists of matrix array to a single numpy arrays by concatenating along axis 1


    # FOM_snapshots["velocity"] = np.concatenate(FOM_snapshots["velocity"], axis=1)
    # FOM_snapshots["pressure"] = np.concatenate(FOM_snapshots["pressure"], axis=1)
    # FOM_snapshots["supremizer"] = np.concatenate(FOM_snapshots["supremizer"], axis=1)

    # subtract lifting function for velocity and supremizer from each column vector

    for i in range(FOM_snapshots["velocity"].shape[1]):
        FOM_snapshots["velocity"][:,i] -= master_ROM.lifting["velocity"]
        FOM_snapshots["supremizer"][:,i] -= master_ROM.lifting["velocity"]

    logging.info(f"shape of FOM_snapshots['velocity'] = {FOM_snapshots['velocity'].shape}")
    logging.info(f"shape of FOM_snapshots['pressure'] = {FOM_snapshots['pressure'].shape}")
    logging.info(f"shape of FOM_snapshots['supremizer'] = {FOM_snapshots['supremizer'].shape}")

    master_FOM.assemble_lifting_matrices(lifting=master_ROM.lifting)

    # FOM Matrices
    master_FOM.assemble_linear_operators()

    # ====================================
    # Build large POD 
    # ====================================

    try:
        # data = dict(np.load(f"results/POD_{args.start}_{args.end}.npz", allow_pickle=True))
        logging.info("Loading POD basis from disk")

        with open(f"results/POD_{args.start}_{args.end}_200_modes.pickle", 'rb') as f:
            data = pickle.load(f)
        
        master_ROM.POD = data
        
    except:
        logging.info("Starting POD (SVD) computation")
        # build and init POD bases 

        master_ROM.POD["primal"]["velocity"]["bunch_size"] = int(FOM_snapshots["velocity"].shape[1]/len(Re))
        master_ROM.POD["primal"]["pressure"]["bunch_size"] = int(FOM_snapshots["pressure"].shape[1]/len(Re))
        master_ROM.POD["primal"]["supremizer"]["bunch_size"] = int(FOM_snapshots["supremizer"].shape[1]/len(Re))

        logging.info(f"bunch size = {master_ROM.POD['primal']['velocity']['bunch_size']} and #snapshots = {FOM_snapshots['velocity'].shape[1]}")    # loop over columns of FOM_snapshots 
        for i in range(FOM_snapshots["velocity"].shape[1]):
            master_ROM.iPOD(FOM_snapshots["velocity"][:, i], type="primal", quantity="velocity", equal_size=False, FIXED_POD_SIZE = 200)
            master_ROM.iPOD(FOM_snapshots["pressure"][:, i], type="primal", quantity="pressure", equal_size=False, FIXED_POD_SIZE = 200)
            master_ROM.iPOD(FOM_snapshots["supremizer"][:, i], type="primal", quantity="supremizer") 

        # logging.info(f"VELOCITY POD size:   {master_ROM.POD['primal']['velocity']['basis'].shape[1]}")
        # logging.info(f"PRESSURE POD size:   {master_ROM.POD['primal']['pressure']['basis'].shape[1]}")
        # logging.info(f"SUPREMIZER POD size: {master_ROM.POD['primal']['supremizer']['basis'].shape[1]}")

        # master_ROM.iPOD(FOM_snapshots["velocity"][:, -1], type="primal", quantity="velocity", equal_size=False, empty_bunch_matrix=True)
        # master_ROM.iPOD(FOM_snapshots["pressure"][:, -1], type="primal", quantity="pressure", equal_size=False, empty_bunch_matrix=True)
        # master_ROM.iPOD(FOM_snapshots["supremizer"][:, -1], type="primal", quantity="supremizer", empty_bunch_matrix=True)

        # master_ROM.iPOD(FOM_snapshots["velocity"], type="primal", quantity="velocity", equal_size=True)
        # master_ROM.iPOD(FOM_snapshots["pressure"], type="primal", quantity="pressure", equal_size=True)
        # master_ROM.iPOD(FOM_snapshots["supremizer"], type="primal", quantity="supremizer")

        logging.info(f"VELOCITY POD size:   {master_ROM.POD['primal']['velocity']['basis'].shape[1]}")
        logging.info(f"PRESSURE POD size:   {master_ROM.POD['primal']['pressure']['basis'].shape[1]}")
        logging.info(f"SUPREMIZER POD size: {master_ROM.POD['primal']['supremizer']['basis'].shape[1]}")

        # save the POD dict to disk in results dir
        np.savez(f"results/POD_{args.start}_{args.end}_200_modes.npz", **master_ROM.POD)
        with open(f"results/POD_{args.start}_{args.end}_200_modes.pickle", 'wb') as f:
            pickle.dump(master_ROM.POD, f)

    # monitor sizes of PODs
    logging.info(f"VELOCITY POD size:   {master_ROM.POD['primal']['velocity']['basis'].shape[1]}")
    logging.info(f"PRESSURE POD size:   {master_ROM.POD['primal']['pressure']['basis'].shape[1]}")
    logging.info(f"SUPREMIZER POD size: {master_ROM.POD['primal']['supremizer']['basis'].shape[1]}")




    # ============================================
    # Calculate timings for different ROM sizes 
    # ============================================

    large_POD = copy.deepcopy(master_ROM.POD)

    TIMINGS = []
    TEST_ROUNDS = 5

    for N in SIZES:
        timings_per_N = 0
        for test_rounds in range(TEST_ROUNDS):
            logging.info(f"Computing ROM for N = {N}")
            master_ROM.POD = copy.deepcopy(large_POD)
            master_ROM.POD["primal"]["velocity"]["basis"] = master_ROM.POD["primal"]["velocity"]["basis"][:, :N]
            master_ROM.POD["primal"]["pressure"]["basis"] = master_ROM.POD["primal"]["pressure"]["basis"][:, :N]
            master_ROM.POD["primal"]["supremizer"]["basis"] = master_ROM.POD["primal"]["supremizer"]["basis"][:, :N]
            
            master_ROM.compute_reduced_matrices()    
            # solve ROM
            tic = time.time()
            master_ROM.solve_primal()
            toc = time.time()
            elapsed_time = toc - tic
            timings_per_N += 3/4*elapsed_time/TEST_ROUNDS # 3/4 since we only consider first 15 s (5s to 20s in FOM setting) 
        TIMINGS.append(timings_per_N)
        logging.info(f"average ROM solve time: {timings_per_N}")

    # save timings to disk in plot dir 
    np.save(f"plots/timings_RE_{Re[parameter_index]}_{args.start}_{args.end}.npy", TIMINGS)
else:
    # load TIMINGS from plots/timings_RE_{Re[parameter_index]}_{args.start}_{args.end}.npy
    TIMINGS = np.load(f"plots/timings_RE_{Re[parameter_index]}_{args.start}_{args.end}.npy")


# ============================================
# Get FOM Timings 
# ============================================
# load results/solve_time_20.0_0.01_mesh_new_{Re}.txt which has columns: nt, t, solve_time 
# and save into np.array 

data = np.loadtxt(f"results/solve_time_{T}_{dt}_mesh_new_{Re[parameter_index]}.txt", delimiter=',', skiprows=1,)

# only use last 15s and neglect first 5s since we start rom at 5s 
index = np.where(master_ROM.fom.time_points >= 5)[0][0]

timing_fom = np.sum(data[index:,2])

SPEED_UP_FOR_REAL_TIME = timing_fom/15

logging.info(f"timing_fom [5,20] = {timing_fom}s = {timing_fom/60}min")
logging.info(f"timing_fom [0,20] = {np.sum(data[:,2])}s = {np.sum(data[:,2])/60}min")
logging.info(f"per timestep = {timing_fom/data[index:,2].shape[0]}s")
logging.info(f"speed-up for real time = {SPEED_UP_FOR_REAL_TIME}")

FONT_SIZE_AXIS = 15
FONT_LABEL_SIZE = 13

speed_ups = timing_fom/TIMINGS

plt.figure()
plt.plot(
    SIZES, 
    speed_ups, 
    linewidth=3,
    color="#1f77b4",
    )

# plot SPEED_UP_FOR_REAL_TIME horizontal line in dashed green plus write on right side of line "real-time threshold"
plt.axhline(y=SPEED_UP_FOR_REAL_TIME, color='g', linestyle='--', linewidth=2)
plt.text(118, 400+SPEED_UP_FOR_REAL_TIME, "real-time ROM", fontsize=FONT_LABEL_SIZE, verticalalignment='center')

# plt.axhline(y=SPEED_UP_FOR_REAL_TIME, color='g', linestyle='--', linewidth=2)

# # plot convergence triangle for 1/SIZES^3 
# plt.plot(
#     SIZES, 
#     1/(np.array(SIZES)**3) * speed_ups[0]*np.array(SIZES[0])**3, 
#     linewidth=2,
#     color="red",
#     linestyle="--",
#     )

# # plot convergence triangle for 1/SIZES^3 
# plt.plot(
#     SIZES, 
#     1/(np.array(SIZES)**2) * speed_ups[0]*np.array(SIZES[0])**2, 
#     linewidth=2,
#     color="yellow",
#     linestyle="--",
#     )

# # plot convergence triangle for 1/SIZES^3 
# plt.plot(
#     SIZES, 
#     1/(np.array(SIZES)) * speed_ups[0]*np.array(SIZES[0]), 
#     linewidth=2,
#     color="orange",
#     linestyle="--",
#     )

plt.xlim([SIZES[0], SIZES[-1]])

plt.grid()
plt.xlabel("POD basis size $(N_u = N_p = N_s)$", fontsize=FONT_SIZE_AXIS)
plt.ylabel("Speed-up", fontsize=FONT_SIZE_AXIS)
# set the font size of the tick labels
plt.tick_params(axis="both", which="major", labelsize=13)
# y acis in log scale
plt.yscale('log')
plt.xlim([SIZES[0], SIZES[-1]])
# plt.show()
plt.xticks([10, 30, 50, 70, 90, 110, 130, 150])

plt.savefig(f"plots/speed_ups_for_{Re[parameter_index]}.pdf")


plt.figure()
plt.plot(
    SIZES, 
    TIMINGS, 
    linewidth=3,
    color="#1f77b4",
    )

# plot convergence triangle for 1/SIZES^3 
plt.plot(
    SIZES, 
    (np.array(SIZES)**3) * TIMINGS[0]/(np.array(SIZES[0])**3), 
    linewidth=2,
    color="red",
    linestyle="--",
    )


# plot convergence triangle for 1/SIZES^3 
plt.plot(
    SIZES, 
    (np.array(SIZES)**2) * TIMINGS[0]/(np.array(SIZES[0])**2), 
    linewidth=2,
    color="yellow",
    linestyle="--",
    )

plt.xlim([SIZES[0], SIZES[-1]])

plt.grid()
plt.xlabel("POD basis size $(N_u = N_p = N_s)$", fontsize=FONT_SIZE_AXIS)
plt.ylabel("ROM TIME", fontsize=FONT_SIZE_AXIS)
# set the font size of the tick labels
plt.tick_params(axis="both", which="major", labelsize=13)
# y acis in log scale
plt.yscale('log')
plt.xlim([SIZES[0]-5, SIZES[-1]+5])
# plt.show()

plt.savefig(f"plots/ROM_timings_for_{Re[parameter_index]}.pdf")
